# Библиотека JSON

JSON (JavaScript Object Notation - формат передачи данных) является легким текстовым форматом обмена данных, основанным на синтаксисе литералов объекта JavaScript (хотя он и не является подгруппой JavaScript).

## Основные методы

### Методы json.dump и json.dumps

__json.dump(obj, fp, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)__

__json.dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)__

Методы сериализуют объект obj в строку JSON формата.  
_Отличия_. Первый метод записывает результат в объект fp, у которого обязательно должен быть метод write(), чаще всего это текстовый файл. Второй же метод реализует все преобразования без дополнительного объекта для записи результата.

_Аргументы_:  
* Если skipkeys=True, тогда ключи словаря не базового типа (str, int, float, bool, None) будут пропущены, вместо того, чтобы вызывать исключение TypeError.
* Когда ensure_ascii=True (по умолчанию), все не-ASCII символы в выводе будут экранированы последовательностями \uXXXX,. Если ensure_ascii=False, эти символы будут записаны как есть.
* Когда check_circular=False, тогда проверка циклических ссылок для типов контейнера будет пропущена, а такие ссылки будут вызывать OverflowError (или ошибку серьёзнее).
* Если allow_nan=False, при каждой попытке сериализировать значение float, выходящее за допустимые пределы (nan, inf, -inf), будет возникать ValueError, в соответствии с сертификацией JSON. В случае если allow_nan=True, будут использованы JavaScript аналоги (NaN, Infinity, -Infinity).
* Когда indent является неотрицательным целым числом или строкой, то объекты и массивы JSON будут выводиться с этим количеством отступов. Если уровень отступа равен 0, отрицательный или "", будут использоваться новые строки без отступов. None (по умолчанию) отражает наиболее компактное представление.
* Separators должны быть tuple (item_separator, key_separator). По умолчанию используется значение (', ', ': ') если indent=None и (',', ': ') при другом значении. Чтобы получить наиболее компактное представление JSON, вы должны указать (',', ':').  
___Изменения в версии 3.4: Используйте(',', ': ') при отступе None.___
* Значение default должно быть функцией. Он вызывается для объектов, которые не могут быть сериализованы. Функция должна вернуть кодируемую версию объекта JSON или вызывать TypeError. Если default не указано, возникает ошибка TypeError.
* Если sort_keys=True, ключи выводимого словаря будут отсортированы.
* Чтобы использовать собственный подкласс JSONEncoder (например, тот который переопределяет метод default() для сериализации дополнительных типов), укажите его с помощью аргумента cls; в противном случае используется JSONEncoder.

```python
>>> f = open('text.txt', 'w') 
>>> json.dump({1:'a',2:'b'}, f)
f # {"1": "a", "2": "b"}
>>> json.dumps({1:'a',2:'b'})  
'{"1": "a", "2": "b"}'
```

### Методы json.load и json.loads

__json.load(fp, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)__

__json.loads(s, *, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)__

Методы десериализуют из объекта fp/s JSON документ в объект Python.  
_Отличия_. Первый метод берет JSON документ из файла/объекта, который поддерживает метод read(), а второй - работает с JSON-объектом из памяти программы.

_Аргументы_:  
* object_hook — опциональная функция, которая применяется к результату декодирования объекта. Использоваться будет значение, возвращаемое этой функцией, а не полученный словарь dict.
* object_pair_shook — опциональная функция, которая применяется к результату декодирования объекта с определенной последовательностью пар ключ/значение. Вместо исходного словаря dict будет использоваться результат, возвращаемый функцией. Если задан object_hook, object_pairs_hook будет в приоритете.
* В случае определения parse_float, он будет вызван для каждого значения JSON с плавающей точкой. По умолчанию, это эквивалентно float(num_str). Можно использовать другой тип данных или парсер для этого значения.
* В случае определения parse_int, он будет вызван для декодирования строк JSON int. По умолчанию, эквивалентен int(num_str). Можно использовать другой тип данных или парсер для этого значения.
* В случае определения parse_constant, он будет вызван для строк: -Infinity, Infinit, NaN. Может быть использован для вызова исключений при обнаружении недопустимых чисел JSON. parse_constant больше не вызывается при null, true, false.
* Чтобы использовать собственный подкласс JSONDecoder, укажите его с помощью аргумента cls; в противном случае используется JSONDecoder. Дополнительные аргументы ключевого слова будут переданы конструктору класса.
* Если десериализованные данные не являются допустимым документом JSON, возникнет JSONDecodeError.

```python
>>> f = open('text.txt', 'r')  
>>> json.load(f)              
{'1': 'a', '2': 'b'}
>>> obj = json.dumps({1:'a',2:'b'}) 
>>> json.loads(obj)
{'1': 'a', '2': 'b'}
```

## Кодировщики и декодировщики

### JSONDecoder

__json.JSONDecoder(*, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, strict=True, object_pairs_hook=None)__

Простой декодер JSON. Является классом.  
При декодировании выполняет следующие преобразования:

<table>
<thead><tr><th>JSON</th><th>Python</th></tr></thead>
<tbody>
    <tr><td>object</td><td>dict</td></tr>
    <tr><td>array</td><td>list</td></tr>
    <tr><td>string</td><td>str</td></tr>
    <tr><td>number (int)</td><td>int</td></tr>
    <tr><td>number (real)</td><td>float</td></tr>
    <tr><td>true</td><td>True</td></tr>
    <tr><td>false</td><td>False</td></tr>
    <tr><td>null</td><td>None</td></tr>
</tbody>
</table>

Он также понимает NaN, Infinity, и -Infinity как соответствующие значения float, которые находятся за пределами спецификации JSON.

_Аргументы_:
* object_hook будет вызван для каждого значения декодированного объекта JSON, а его возвращаемое значение будет использовано в указанном месте dict. Может быть использовано для обеспечения десериализации.
* object_pairs_hook будет вызван для каждого значения декодированного объекта JSON с упорядоченным списком пар. Возвращаемое значение object_pairs_hook будет использовано вместо dict. Эта функция может использоваться для запуска стандартного декодера. Если object_hook так же определён, в приоритете будет object_pairs_hook.
* parse_float будет вызван для каждого значения JSON с плавающей точкой. По умолчанию, это эквивалентно float(num_str). Может быть использован для другого типа данных или парсера JSON float.
* parse_int будет вызван для строки JSON int. По умолчанию, эквивалентно int(num_str). Может быть использован для других типов данных и парсеров целых чисел JSON.
* parse_constant будет вызван для строк: '-Infinity', 'Infinity', 'NaN'. Можно использовать для вызова исключений при обнаружении недопустимых чисел JSON.
* Если strict=False, тогда использование управляющих символов внутри строк будет разрешено. _В данном контексте управляющие символы — это символы с кодами в диапазоне 0–31, включая \t (tab), \n, \r и \0._
* Если десериализованные данные не являются допустимым документом JSON, будет вызвана ошибка JSONDecodeError.

__decode(s)__

Возвращает представление s в Python (str — содержащий документ JSON). JSONDecodeError будет вызвана, если документ JSON не валидный (или не действительный).

__raw_decode(s)__

Декодирует документ JSON из s (str начинающийся с JSON документа) и возвращает кортеж из 2-х элементов (представление Python и индекс строки в s, на которой закончился документ). Может использоваться для декодирования документа JSON из строки, которая имеет дополнительные данные в конце.

```python
>>> obj
'{"1": "a", "2": "b"}'
>>> json.JSONDecoder().decode(obj)   
{'1': 'a', '2': 'b'}
>>> json.JSONDecoder().raw_decode(obj)
({'1': 'a', '2': 'b'}, 20)
```

### JSONEncoder

__json.JSONEncoder(*, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, sort_keys=False, indent=None, separators=None, default=None)__

Расширяемый кодировщик JSON для структур данных Python. Является классом.  
Поддерживает следующие типы данных и объекты по умолчанию:

<table>
<thead><tr><th>Python</th><th>JSON</th></tr></thead>
<tbody>
    <tr><td>dict</td><td>object</td></tr>
    <tr><td>list, tuple</td><td>array</td></tr>
    <tr><td>str</td><td>string</td></tr>
    <tr><td>int, float</td><td>number</td></tr>
    <tr><td>True</td><td>true</td></tr>
    <tr><td>False</td><td>false</td></tr>
    <tr><td>None</td><td>null</td></tr>
</tbody>
</table>

Для того, чтобы можно было распознавать и другие объекты, подкласс должен выполнить метод default(), который вернет сериализуемый объект для o, если это возможно, в противном случае он должен вызвать реализацию родительского класса (для вызова TypeError).

_Аргументы_:
* Если skipkeys=False (по умолчанию), вызывается TypeError при попытке кодировать ключи, которые не являются str, int, float или None. В случае если skipkeys=True, такие элементы просто пропускаются.
* Если ensure_ascii=True (по умолчанию), на выходе гарантируется, что все входящие не-ASCII символы экранируются последовательностями \uXXXX. Но если ensure_ascii=False, эти символы будут выводиться как есть.
* Если check_circular=True (по умолчанию), тогда списки, словари и самостоятельно закодированные объекты будут проверяться на циклические ссылки во время кодировки, чтобы предотвратить бесконечную рекурсию (что вызовет OverflowError). В другом случае, такая проверка не выполняется.
* Если allow_nan=True (по умолчанию), тогда NaN, Infinity, и -Infinity будут кодированы как таковые. Это не соответствует спецификации JSON, но соответствует большинству кодировщиков и декодеров на основе JavaScript. В другом случае такие значения вызовут ValueError.
* Если sort_keys=True, выводимый словарь будет отсортирован по именам ключей.
* Если indent является неотрицательным целым числом или строкой, то объекты и массивы JSON будут выводиться с этим количеством отступов. Если уровень отступа равен 0, отрицательный или "", будут использоваться новые строки без отступов. None (по умолчанию) отражает наиболее компактное представление.
* Если указан separator (должен быть tuple типа (item_separator, key_separator)). По умолчанию используется (', ', ': '), если indent=None, и (',', ': '), если нет.
* Значение default должно быть функцией. Она вызывается для объектов, которые не могут быть сериализованы. Функция должна вернуть кодируемую версию объекта JSON или вызывать TypeError. Если default не указано, возникает ошибка TypeError. Рекомендуется встраивать default() в сам объект.

__encode(o)__

Возвращает строковое представление JSON структуры данных Python.

__iterencode(o)__

Кодирует переданный объект o и выдаёт каждое строковое представление, как только оно становится доступным.

```python
>>> json.JSONEncoder().encode({"foo": ["bar", "baz"]})   
'{"foo": ["bar", "baz"]}'

# пример того, как может быть использован iterencode()
for chunk in json.JSONEncoder().iterencode(bigobject):
    mysocket.write(chunk)
```

## Исключение JSONDecodeError

__json.JSONDecodeError(msg, doc, pos)__

Подкласс ValueError с дополнительными атрибутами:
* msg — не отформатированное сообщение об ошибке.
* doc — парсинг JSON документа.
* pos — первый индекс doc, если парсинг неудачный.
* lineno — строка, соответствующая pos.
* colno — колонка, соответствующая pos.

## Ограничения реализации

Некоторые реализации десериализатора JSON имеют лимиты на:
* размер принимаемого текста JSON
* максимальный уровень вложенности объектов и массивов JSON
* диапазон и точность чисел JSON
* содержание и максимальная длина строк JSON

Этот модуль не ставит никаких ограничений, кроме тех, которые относятся к соответствующим типам Python или самому интерпретатору Python.  
При сериализации в JSON будьте осторожны с такими ограничениями в приложениях, которые могут потреблять ваш JSON. В частности, числа в JSON часто десериализуются в числа двойной точности IEEE 754 и подвержены ограничениям диапазона и точности этого представления. Это особенно актуально при сериализации значений Python int чрезвычайно большой величины или при сериализации экземпляров «необычных» числовых типов.